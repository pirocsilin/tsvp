<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="do.sibsutis.ru">

  <title>Тема 3. Конспект лекций</title>
	
	<link rel="icon" type="image/png" href="../lib/css/favicon.png">
  <!-- Bootstrap Core CSS -->
  <link href="../lib/css/bootstrap.css" rel="stylesheet">
	
  <!-- Custom CSS -->
  <link href="../lib/css/scrolling-nav.css" rel="stylesheet">

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
  <![endif]-->
</head>

<!-- The #page-top ID is part of the scrolling feature - the data-spy and data-target are part of the built-in Bootstrap scrollspy function -->

<body id="page-top" data-spy="scroll" data-target=".navbar-fixed-top">
  <!-- Navigation -->
<nav class="navbar navbar-default navbar-fixed-top">
 <div class="container">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
   <li class="hidden"> <a class="page-scroll" href="#page-top"></a> </li>
	 
	 <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
   </button>
	 
   <a class="navbar-brand " href="../index.htm"> 
  <text class = "hidden-xs">Теория сложности вычислительных процессов и структур</text> 
  <text class = "visible-xs">ТСВП и С</text>
	 </a>
  </div>

  <!-- Collect the nav links, forms, and glyphicon glyphicon-list-alt content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
   
	 <!-- <ul class="nav navbar-nav">
		<li><a href="#"></a></li> 
   </ul> -->
	
   <ul class="nav navbar-nav navbar-right">
    <li class="dropdown">
		<button type="button" class="navbar-toggle dropdown-toggle hidden-xs" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
		</button>	   
		<a class = "dropdown-toggle visible-xs" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Материалы</a>
     <ul class="dropdown-menu">
    <li><a href="../index.htm">Аннотация курса</a></li>
      <li role="separator" class="divider"></li>
      <li><a href="lec_index.htm">Теория</a></li>
	<!--li><a href="Posobie.htm">Учебное пособие</a></li-->

        <li><a href="labs.htm">Лабораторные работы</a></li>   
     <li><a href="c_work.htm">Контрольная работа</a></li>
      <li role="separator" class="divider"></li>
       <li><a href="lit.htm">Литература</a></li>
      <!--li><a href="q.htm">Вопросы для самопроверки</a></li-->			
     </ul>
 </li>
 </ul>
  </div><!-- /.navbar-collapse -->
 </div><!-- /.container-fluid -->
</nav>


  <div id="intro" class="section content-section ">
    <div class="container">
       <div class="row">
        <div class="col-lg-12">	


<!-- содержание -->	
<div class="page-header">				

<h3><a href="#">3 ЗАДАЧИ  НА ГРАФАХ</a></h3>
<a href="#1" class=punkt>3.1 Справочный материал</a><br>

<a href="#2" class=punkt>3.2 Поиск минимального остова в связном неориентированном взвешенном графе </a><br>

<a href="#3" class=punkt>3.3 Нахождение кратчайшего расстояния</a><br>

<a href="#4" class=punkt>3.4 Нахождение диаметра, радиуса и центра графа</a><br>

<a href="#5" class=punkt>3.5 Задача об изоморфизме графов</a><br>

<a href="#6" class=punkt>3.6 Задача коммивояжера. Ее решение методом ветвей и границ</a><br>

</div>
<!--начало-->
<a name=1 class="anchor"></a>

<h3>3.1 Справочный материал</h3>

<P>Кратко напомним определения, известные из курса дискретной математики.</P>
<P><I><B> Определеия: 
  </B>Граф</I> – пара <IMG SRC="img/image140.gif" WIDTH=56 HEIGHT=21 align="absmiddle">, 
  где <I>V={ V<SUB>1</SUB>, V<SUB>2</SUB>,…, V<SUB>n </SUB>}</I> – множество вершин 
  графа <I>G, E</I> – множество дуг (рёбер) графа: <I>E={ (V<SUB>1i</SUB>,V<SUB>2i</SUB>)}.</I></P>
<P>Рёбра можно 
  задавать разными способами, например матрицей инцидентности или списком рёбер.</P>
<P><I>Неориентированный 
  граф</I> – граф, удовлетворяющий условию, </P>
<P>что если 
  <IMG SRC="img/image141.gif" WIDTH=65 HEIGHT=21>, то и <IMG SRC="img/image142.gif" WIDTH=65 HEIGHT=21>, 
  т.е. порядок расположения концов дуг графа не существенен.</P>
<P>Матрица инцидентности такого 
  графа симметрична.</P>
<P><I>Взвешенный 
  граф</I> – граф, каждой дуге которого приписан её вес.</P>
<P><I>Цикл 
  в графе</I> – маршрут, заданный последовательностью вершин, каждая вершина посещается 
  по одному разу, и начальная вершина совпадает с конечной.</P>
<P><I> Граф 
  без циклов</I> – куст.</P>
<P><I>Связный 
  граф</I> – граф, из любой вершины которого можно дойти до любой другой. </P>
<P><I>Связный 
  куст</I> – дерево.</P>
<P><I>Компонента 
  связности</I> – совокупность вершин, для каждой из которых существует путь в 
  любую другую вершину этой совокупности. </P><br>
<a name=2 class="anchor"></a><h3>3.2 
  Поиск минимального остова в связном неориентированном взвешенном графе</h3>
<P><U>Задача:</U> 
  <I>Дан граф G=(V,E) – связный, неориентированный, взвешенный. Нам нужно выделить 
  в нем минимальный (по суммарному весу ребер) связный граф с теми же вершинами 
  – остов ( остовное дерево), т.е. исключить из графа часть ребер таким образом, 
  чтобы сумма весов оставшихся была минимальна, и получившийся граф по- прежнему 
  был связным.</I></P>
<P><B><U>Идея 
  решения</U>: </B>Для решения этой задачи обычно применяется <I>алгоритм Краскала</I> 
  (классический пример т.н. “жадного алгоритма”).</P>
<I> 
<P>Алгоритм Краскала:</P>
</I> 
<P>1. Сначала 
  упорядочиваем все ребра по возрастанию весов.</P>
<P>2. Заводим 
  таблицу: в левой колонке список ребер, в правой компоненты связности.</P>
<P>3. В первой 
  строчке список ребер пустой и все компоненты связности одновершинные. Берем 
  минимальное по стоимости (по весу) ребро и включаем его в список ребер. Соответствующие 
  две вершины объединяем в одну компоненту связности.</P>
<P>4. Берем 
  следующее по стоимости ( весу) ребро, добавляем к содержимому предыдущей строчки 
  левого столбца; объединяем компоненты связности. Если концы ребра уже принадлежат 
  одной и той же компоненте связности, то данное ребро в состав минимального остова 
  не включается.</P>
<P>5. Повторяем 
  эти операции до тех пор, пока все вершины не окажутся в одной единственной компоненте 
  связности (для этого потребуется включить в </P>
<P>состав остова 
  ровно <I>n–1</I> ребро).</P>
<P><I><B>Пример: </B></I>Пусть 
  имеется граф, изображённый на рисунке 3.1.</P>
<P></P>
<P><IMG SRC="img/image143.gif" ></P>
<p>Рисунок 
  3.1 Исходный граф </p>
<P><I><B>Решение: </B></I>Составим 
  таблицу, в которой будем отражать порядок выбора ребер для минимального остова.</P>
<P> 
  <TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=568>
    <TR> 
      <TD WIDTH="50%" VALIGN="TOP"> <P ALIGN="CENTER"> <B>Подграф 
          (ребра)</B></TD>
      <TD WIDTH="50%" VALIGN="TOP"> <B> 
        <P ALIGN="CENTER">Связи 
          (компоненты связности)</B></TD>
    </TR>
    <TR> 
      <TD WIDTH="50%" VALIGN="TOP"> <P ALIGN="CENTER"><IMG SRC="img/image64.gif" WIDTH=12 HEIGHT=22>пустой</TD>
      <TD WIDTH="50%" VALIGN="TOP"> <P ALIGN="CENTER">1,2,3,4,5,6,7</TD>
    </TR>
    <TR> 
      <TD WIDTH="50%" VALIGN="TOP"> <P ALIGN="CENTER">(1,7) 
          – минимально по цене.</TD>
      <TD WIDTH="50%" VALIGN="TOP"> <P ALIGN="CENTER">(1,7),2,3,4,5,6 
          </TD>
    </TR>
    <TR> 
      <TD WIDTH="50%" VALIGN="TOP"> <P ALIGN="CENTER">(1,7)+(3,4)</TD>
      <TD WIDTH="50%" VALIGN="TOP"> <P ALIGN="CENTER">(1,7),2,(3,4),5,6</TD>
    </TR>
    <TR> 
      <TD WIDTH="50%" VALIGN="TOP"> <P ALIGN="CENTER">(1,7)(3,4)+(2,7)<</TD>
      <TD WIDTH="50%" VALIGN="TOP"> <P ALIGN="CENTER">(1,2,7),(3,4),5,6</TD>
    </TR>
    <TR> 
      <TD WIDTH="50%" VALIGN="TOP"> <P ALIGN="CENTER">(1,7)(3,4)(2,7)+(2,3)</TD>
      <TD WIDTH="50%" VALIGN="TOP"> <P ALIGN="CENTER">(1,2,3,4,7),5,6</TD>
    </TR>
    <TR> 
      <TD WIDTH="50%" VALIGN="TOP"> <P ALIGN="CENTER">(1,7)(3,4)(2,7)(2,3) 
          +(3,7) <SUP>&#9674;</SUP></TD>
      <TD WIDTH="50%" VALIGN="TOP"> <P ALIGN="CENTER">(1,2,3,4,7),5,6></TD>
    </TR>
    <TR> 
      <TD WIDTH="50%" VALIGN="TOP" HEIGHT=4> <P ALIGN="CENTER">(1,7)(3,4)(2,7)(2,3) 
          +(4,7) <SUP>&#9674;&#9674;</SUP></TD>
      <TD WIDTH="50%" VALIGN="TOP" HEIGHT=4> <P ALIGN="CENTER">(1,2,3,4,7),5,6</TD>
    </TR>
    <TR> 
      <TD WIDTH="50%" VALIGN="TOP"> <P ALIGN="CENTER">(1,7)(3,4)(2,7)(2,3)+(4,5)</TD>
      <TD WIDTH="50%" VALIGN="TOP"> <P ALIGN="CENTER">(1,2,3,4,5,7),6</TD>
    </TR>
    <TR> 
      <TD WIDTH="50%" VALIGN="TOP"> <P ALIGN="CENTER">(1,7)(3,4)(2,7)(2,3)(4,5) 
          +(1,2) <SUP>&#9674;&#9674;&#9674;</SUP></TD>
      <TD WIDTH="50%" VALIGN="TOP"> <P ALIGN="CENTER">(1,2,3,4,5,7),6</TD>
    </TR>
    <TR> 
      <TD WIDTH="50%" VALIGN="TOP"> <P ALIGN="CENTER">(1,7)(3,4)(2,7)(2,3)(4,5)+(1,6)></TD>
      <TD WIDTH="50%" VALIGN="TOP"> <P ALIGN="CENTER">(1,2,3,4,5,6,7)</TD>
    </TR>
  </TABLE>

</P> <B> 
<P><U>Пояснения</U>:</P>
</B> 
<P>&#9674; 
  – вершины 3 и 7 уже находятся в одной компоненте связности на момент включения 
  в остов ребра (3,7); </P>
<P>&#9674;&#9674; 
  – следующее по весу ребро – (4, 7), однако вершины 4 и 7 уже находятся в одной 
  компоненте связности на момент включения в остов ребра (4,7);</P>
<P>&#9674;&#9674;&#9674; 
  – аналогично.</P>
<P><B> Теорема 3.1: </B>Алгоритм 
  Краскала всегда выдает минимальный по стоимости остов.</P>
<P><I><B> Доказательство: 
  </B></I>Заметим, что в результате работы алгоритма Краскала мы всегда получаем 
  дерево (так как мы не включаем ребра, вершины которых лежат в одной компоненте 
  связности, следовательно, возникновение циклов невозможно).</P>
<P>Предположим, 
  что получившееся в результате работы алгоритма Краскала дерево не минимально 
  по своей стоимости и существует другое, предположительно “оптимальное” дерево. 
  Например, такое, как на рисунке 3.2. Цифрами в кружочках обозначены ребра в 
  порядке их добавления в дерево.</P>
<P><IMG SRC="img/image144.gif"></P>
<P>Рисунок 3.2 
  </P>
<P>Рассмотрим 
  подробно тот этап работы алгоритма Краскала, на котором мы впервые добавили 
  в остов “неправильное” ребро, т.е. то, которого нет в “оптимальном” дереве. 
  Первые два по порядку добавления ребра (3,6) и (6,5) присутствуют в “оптимальном” 
  дереве. Расхождение начинается после добавления ребра (7,8).</P>
<P>Добавим 
  ребро (7,8) к “оптимальному” дереву (см. рис 3.3):</P>
<P><IMG SRC="img/image145.gif" ></P>
<P>Рисунок 3.3</P>
<P>При этом 
  в “оптимальном” дереве возникает цикл, и мы можем убрать из него любое ребро, 
  например, (1,2), участвующее в цикле, и при этом граф останется связанным. Заметим, 
  что при этом общий вес полученного дерева будет меньше веса “оптимального” дерева, 
  т.к. ребро (7,8) самое меньшее по весу в этом цикле (т.к. в алгоритме Краскала 
  мы по очереди добавляем все ребра, начиная с самого минимального по весу, меньше 
  ребра (7,8) по весу только ребра (3,6) и (6,5), а они в этот цикл не входят). 
  В этом примере мы можем построить меньший, чем предполагаемый “оптимальный”, 
  по суммарному весу остов:</P>
<P><IMG SRC="img/image146.gif" WIDTH=272 HEIGHT=120></P>
<P>Рисунок 3.4 
  Минимальный остов</P>
<P>Он отличается 
  от “оптимального” заменой ребра (1,2) на меньшее по весу ребро (7,8). </P>
<P>Данные рассуждения 
  можно обобщить для случая произвольного графа.</P>
<B> 
<P> <I>Теорема 
  доказана.</I></P>
</B> <I> 
<P><U> Оценим 
  трудоемкость работы алгоритма Краскала</U>: </P>
</I> 
<P>Пусть в 
  графе было <I>n</I> вершин и k ребер <IMG SRC="img/image147.gif" WIDTH=110 HEIGHT=41 align="absmiddle">. 
  При быстрой сортировке на первый этап работы алгоритма затрачиваем <I>k log</I> 
  <I>k</I> действий. Далее нам потребуется ровно <I>(n–1)</I> результативных этапов 
  (результативным будем считать этап работы алгоритма, в результате которого осуществляется 
  добавление ребра к минимальному остову и слияние компонент связности), и не 
  больше, чем <I>k–(n–1)</I> нерезультативных этапов. Нерезультативный этап состоит 
  из одного сравнения – проверки принадлежности вершин добавляемого ребра на нахождение 
  в одной компоненте связности. В случае же результативного этапа мы должны переприсвоить 
  номера компонент связности всем n вершинам – итого n действий.</P>
<P>Таким образом, 
  трудоемкость алгоритма Краскала:</P>
<P> <IMG SRC="img/image148.gif" WIDTH=341 HEIGHT=29></P>
<P>Следовательно, 
  алгоритм Краскала – полиномиальный.</P><br>
<a name=3 class="anchor"></a> 
<h3>3.3 Нахождение 
  кратчайшего расстояния</h3>

<P>Дан связный 
  неориентированный взвешенный граф <I>G</I>. Если существует ребро с вершинами 
  <I>v<SUB>i</SUB></I> и <I>v<SUB>j </SUB></I>, то стоимость перехода из <I>v<SUB>i</SUB></I> 
  в <I>v<SUB>j </SUB></I> составит <img src="img/image149.gif" align="texttop">. 
  Если же ребра <I>v<SUB>i</SUB>– v<SUB>j </SUB></I> нет, то полагаем <IMG SRC="img/image150.gif" align="texttop" >. 
  </P>
<P>На входе 
  в данном графе выделяется вершина <I>v<SUB>0</SUB></I>. Надо найти кратчайшее 
  расстояние от <I>v<SUB>0</SUB></I> до всех остальных вершин. </P>
<P>Для решения 
  задачи поиска кратчайшего расстояния используется (кроме прямого перебора) два 
  алгоритма: Форда – Беллмана и Дейкстры.</P>
<P>Рассмотрим 
  простейший алгоритм поиска кратчайшего расстояния – алгоритм Форда-Беллмана. 
  Этот алгоритм является классическим примером алгоритма на поиск транзитивного 
  замыкания.</P>
<I><U> 
<P>Общая идея 
  работы всех алгоритмов на поиск транзитивного замыкания:</P>
</U></I> 
<P>Пересчитываем 
  что-либо (в нашем случае, стоимости вершин) до тех пор, пока это что-то не стабилизируется. 
  Как только произойдёт стабилизация, необходимо остановиться. Ответ получен.</P>
<B> 
<P>3.3.1 Алгоритм  Форда – Беллмана</P>
</B> 
<P>Формируем массив <IMG SRC="img/image151.gif" WIDTH=54 HEIGHT=30>– 
  минимально возможная стоимость переезда (перехода, перевозки) из вершины <I>v<SUB>0</SUB></I> 
  в <I>v<SUB>i</SUB> </I> на каждом этапе работы нашего алгоритма. </P>
<P>Первоначально он задается 
  как <IMG SRC="img/image152.gif" WIDTH=162 HEIGHT=29>.</P>
<P>Затем пересчитываем стоимости 
  всех вершин по формуле</P>
<P> <IMG SRC="img/image153.gif" WIDTH=250 HEIGHT=42>&#9; 
  <I> <B>(3.1)</B></I> </P>
<P>до тех пор, пока система 
  не стабилизуется (так называемое <I>транзитивное замыкание</I>). В результате 
  мы получим стоимости переезда из каждой вершины графа до заданной <I>v<SUB>0</SUB> 
  </I> и эти стоимости будут минимально возможными.</P>
<P><I><B> Пример: </B></I> 
  Дан граф (рис. 3.5). Найти расстояние от нулевой вершины до всех остальных. 
  </P>
<P><IMG SRC="img/image154.gif" ></P>
<P>Рисунок 3.5 
  Исходный граф</P>
<B><I> 
<P>Решение:</P>
</I></B> 
<P> <img src="img/image155.gif" ></P>
<p>Рисунок 3.6 
  Стоимости переездов из вершины v<SUB>0</SUB></P>
<P>Первоначальный 
  массив стоимостей переходов выглядит так: </P>
<P><I>D<SUP>(0)</SUP>=(0, 
  <IMG SRC="img/image156.gif" WIDTH=68 HEIGHT=17>)</I>. Сосчитаем стоимость вершины<I> 
  i</I> на <I>k</I>-том шаге. В вершину <I>i </I>мы могли попасть из нулевой вершины, 
  из первой вершины и т.д.</P>
<P>Тогда: </P>
<P><I> D<SUP>(k+1)</SUP>(i)= 
  (D<SUP>(k)</SUP>(0) + (0,i),D<SUP>(k)</SUP>(1) +(1,i),…………. )</I></P>
<P> стоимость 
  перехода из стоимость вершины 0 на предыдущем шаге +</P>
<P> вершины 
  0 в вершину <I>i</I>. стоимость переезда из нулевой вершины в <I>i</I>-ую. </P>
<P>Стоимость 
  вершины <I>i</I> на каждом шаге считаем по формуле <B><I>(3.1)</I></B>:</P>
<P><IMG SRC="img/image157.gif" WIDTH=634 HEIGHT=24>.</P>
<P>Вычислим 
  стоимости вершин данного графа на первом шаге:</P>
<B> 
<P><IMG SRC="img/image158.gif" WIDTH=629 HEIGHT=24></P>
</B> 
<P> <IMG SRC="img/image159.gif" WIDTH=430 HEIGHT=22>;</P>
<P><IMG SRC="img/image160.gif" WIDTH=646 HEIGHT=24>&#9;&#9; 
  <IMG SRC="img/image161.gif" WIDTH=421 HEIGHT=22>;</P>
<P><IMG SRC="img/image162.gif" WIDTH=641 HEIGHT=24>&#9;&#9; 
  <IMG SRC="img/image163.gif" WIDTH=402 HEIGHT=22>;</P>
<P><IMG SRC="img/image164.gif" WIDTH=646 HEIGHT=24>&#9;&#9; 
  <IMG SRC="img/image165.gif" WIDTH=406 HEIGHT=22>.</P>
<P>Вычислим 
  стоимости вершин данного графа на втором шаге:</P>
<P><IMG SRC="img/image166.gif" WIDTH=622 HEIGHT=24></P>
<P> <IMG SRC="img/image167.gif" WIDTH=426 HEIGHT=22>;</P>
<P><IMG SRC="img/image168.gif" WIDTH=640 HEIGHT=24>&#9;&#9; 
  <IMG SRC="img/image169.gif" WIDTH=414 HEIGHT=22>;</P>
<P><IMG SRC="img/image170.gif" WIDTH=634 HEIGHT=24></P>
<P> <IMG SRC="img/image171.gif" WIDTH=385 HEIGHT=22>;</P>
<P><IMG SRC="img/image172.gif" WIDTH=640 HEIGHT=24><IMG SRC="img/image173.gif" WIDTH=394 HEIGHT=22> 
  – наблюдается стабилизация.</P>
<P>Вычислим 
  стоимости вершин данного графа на третьем шаге:</P>
<P><IMG SRC="img/image174.gif" WIDTH=469 HEIGHT=24>;</P>
<P><IMG SRC="img/image175.gif" WIDTH=452 HEIGHT=24>;</P>
<P><IMG SRC="img/image176.gif" WIDTH=429 HEIGHT=24>– 
  стабилизация;</P>
<P><IMG SRC="img/image177.gif" WIDTH=434 HEIGHT=24>– 
  стабилизация.</P>
<P>Вычислим 
  стоимости вершин данного графа на четвёртом шаге:</P>
<P><IMG SRC="img/image178.gif" WIDTH=462 HEIGHT=24>;</P>
<P><IMG SRC="img/image179.gif" WIDTH=440 HEIGHT=24>– 
  стабилизация;</P>
<P><IMG SRC="img/image180.gif" WIDTH=424 HEIGHT=24>– 
  стабилизация;</P>
<P><IMG SRC="img/image181.gif" WIDTH=429 HEIGHT=24>– 
  стабилизация.</P>
<P>Вычислим 
  стоимости вершин данного графа на пятом шаге:</P>
<P><IMG SRC="img/image182.gif" WIDTH=461 HEIGHT=24>– 
  стабилизация;</P>
<P><IMG SRC="img/image183.gif" WIDTH=438 HEIGHT=24>– 
  стабилизация;</P>
<P><IMG SRC="img/image184.gif" WIDTH=424 HEIGHT=24>– 
  стабилизация;</P>
<P><IMG SRC="img/image185.gif" WIDTH=428 HEIGHT=24>– 
  стабилизация.</P>
<P>Массив стоимостей 
  вершин перестал изменяться. Таким образом, мы получили кратчайшие расстояния 
  от всех вершин данного графа до нулевой вершины. </P>
<B> 
<P></P>
</B> 
<P>Оценим <I>трудоемкость</I> 
  алгоритма Форда-Беллмана:</P>
<P>В нем участвуют 
  три цикла: внешний типа While выполняется до тех пор, пока не произошла стабилизация. 
  Следующий по вложенности цикл – по вершинам графа. Самый внутренний цикл (нахождение 
  минимума) – по переменной j.</P>
<P>Итого, <I>T(n) 
  = l&#8729;n&#8729;n, </I>где <I>l – </I>количество проходов внешнего цикла While. 
  Так как <I>l</I> &#8804; <I>n</I> (потому что самый длинный оптимальный маршрут 
  включает в себя прохождение n–1 вершин, плюс делаем еще один проход, чтобы убедиться 
  в стабилизации)<I> </I>, то <I>2n<SUP>2 </SUP>&#8804; T(n) &#8804; n<SUP>3</SUP></I></P>
<B> 
<p>3.3.2 Алгоритм 
  Дейкстры</P>
<P><U>Описание 
  алгоритма Дейкстры</U>:</P>
</B> 
<P>Ищем расстояние 
  от нулевой вершины.</P>
<I> 
<P>S = {o}</P>
<P>D[i] = C(0,i) 
  i = 0……n</P>
<P>While S 
  &#8800; V do</P>
</I> 
<OL>
  <P> 
  <LI>выбираем вершину <I>w</I>, 
    которая принадлежит множеству вершин <I>V\S</I> (<I>V</I> без <I>S</I>) с 
    минимальной стоимостью <I>D(w)</I> </LI>
  <LI> <I> S:=S+ w</I> (добавляем 
    вершину <I>w </I> к множеству <I>S </I>)</LI>
  <LI>для всех вершин v<IMG SRC="img/image186.gif" WIDTH=13 HEIGHT=13> 
     
</OL>
V\S do D(v):=min( D(v), D(w)+С(w, 
v) ) пересчитываем стоимости всех остальных вершин</LI></P>  
<P><I><B> Пример: </B></I>Рассмотрим работу алгоритма на уже знакомом 
  графе:</P>
<P><IMG SRC="img/image154.gif" ></P>
<P>Рисунок 3.7 Исходный граф</P>
<P><I><B>Решение: </B></I>Составим таблицу:</P>
 
<P> 

  <TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=440>
    <TR> 
      <TD WIDTH="21%" VALIGN="TOP"> <B> 
        <P ALIGN="CENTER">S</B></TD>
      <TD WIDTH="10%" VALIGN="TOP"> <P ALIGN="CENTER"><I><B>w</B></I></TD>
      <TD WIDTH="20%" VALIGN="TOP"> <B> 
        <P ALIGN="CENTER">D(<I>w</I>)</B></TD>
      <TD WIDTH="12%" VALIGN="TOP"> <B> 
        <P ALIGN="CENTER">D(1)</B></TD>
      <TD WIDTH="14%" VALIGN="TOP"> <P ALIGN="CENTER"><B>D(2)</B></TD>
      <TD WIDTH="11%" VALIGN="TOP"> <B> 
        <P ALIGN="CENTER">D(3)</B></TD>
      <TD WIDTH="11%" VALIGN="TOP"> <B> 
        <P ALIGN="CENTER">D(4)</B></TD>
    </TR>
    <TR> 
      <TD WIDTH="21%" VALIGN="TOP"> <P ALIGN="CENTER">0</TD>
      <TD WIDTH="31%" VALIGN="TOP" COLSPAN=2> <P ALIGN="CENTER">Не 
          определены</TD>
      <TD WIDTH="12%" VALIGN="TOP"> <P ALIGN="CENTER">25</TD>
      <TD WIDTH="14%" VALIGN="TOP"> <P ALIGN="CENTER">15</TD>
      <TD WIDTH="11%" VALIGN="TOP"> <P ALIGN="CENTER">7</TD>
      <TD WIDTH="11%" VALIGN="TOP"> <P ALIGN="CENTER">2</TD>
    </TR>
    <TR> 
      <TD WIDTH="21%" VALIGN="TOP"> <P ALIGN="CENTER">(0,4)</TD>
      <TD WIDTH="10%" VALIGN="TOP"> <P ALIGN="CENTER">4</TD>
      <TD WIDTH="20%" VALIGN="TOP"> <P ALIGN="CENTER">2</TD>
      <TD WIDTH="12%" VALIGN="TOP"> <P ALIGN="CENTER">25 
          <SUP>&#9674;</SUP></TD>
      <TD WIDTH="14%" VALIGN="TOP"> <P ALIGN="CENTER">15</TD>
      <TD WIDTH="11%" VALIGN="TOP"> <P ALIGN="CENTER">5</TD>
      <TD WIDTH="11%" VALIGN="TOP"> <P ALIGN="CENTER">&#9472; 
          <SUP>&#9674;&#9674;</SUP></TD>
    </TR>
    <TR> 
      <TD WIDTH="21%" VALIGN="TOP"> <P ALIGN="CENTER">(0,4,3)</TD>
      <TD WIDTH="10%" VALIGN="TOP"> <P ALIGN="CENTER">3</TD>
      <TD WIDTH="20%" VALIGN="TOP"> <P ALIGN="CENTER">5</TD>
      <TD WIDTH="12%" VALIGN="TOP"> <P ALIGN="CENTER">25</TD>
      <TD WIDTH="14%" VALIGN="TOP"> <P ALIGN="CENTER">9 
          <SUP>&#9674;&#9674;&#9674;</SUP></TD>
      <TD WIDTH="11%" VALIGN="TOP"> <P ALIGN="CENTER">&#9472;</TD>
      <TD WIDTH="11%" VALIGN="TOP"> <P ALIGN="CENTER">&#9472;</TD>
    </TR>
    <TR> 
      <TD WIDTH="21%" VALIGN="TOP"> <P ALIGN="CENTER">(0,4,3,2)</TD>
      <TD WIDTH="10%" VALIGN="TOP"> <P ALIGN="CENTER">2</TD>
      <TD WIDTH="20%" VALIGN="TOP"> <P ALIGN="CENTER">9</TD>
      <TD WIDTH="12%" VALIGN="TOP"> <P ALIGN="CENTER">15</TD>
      <TD WIDTH="14%" VALIGN="TOP"> <P ALIGN="CENTER">&#9472;</TD>
      <TD WIDTH="11%" VALIGN="TOP"> <P ALIGN="CENTER">&#9472;</TD>
      <TD WIDTH="11%" VALIGN="TOP"> <P ALIGN="CENTER">&#9472;</TD>
    </TR>
    <TR> 
      <TD WIDTH="21%" VALIGN="TOP"> <P ALIGN="CENTER">(0,4,3,2,1)</TD>
      <TD WIDTH="10%" VALIGN="TOP"> <P ALIGN="CENTER">1</TD>
      <TD WIDTH="20%" VALIGN="TOP"> <P ALIGN="CENTER">15</TD>
      <TD WIDTH="12%" VALIGN="TOP"> <P ALIGN="CENTER">&#9472;</TD>
      <TD WIDTH="14%" VALIGN="TOP"> <P ALIGN="CENTER">&#9472;</TD>
      <TD WIDTH="11%" VALIGN="TOP"> <P ALIGN="CENTER">&#9472;</TD>
      <TD WIDTH="11%" VALIGN="TOP"> <P ALIGN="CENTER">&#9472;</TD>
    </TR>
  </TABLE>

</P> <B><U> 
<P>Пояснения:</P>
</U> </B> 
<P>&#9674; 
  – 25 = min(25, 2+<IMG SRC="img/image187.gif" WIDTH=16 HEIGHT=13>), где C(4,1)= 
  <IMG SRC="img/image188.gif" WIDTH=16 HEIGHT=13> – стоимость перехода напрямую 
  от 4 вершины к первой, так как эти вершины не соединены ребром;</P>
<P>&#9674;&#9674; 
  – стоимость маршрута от нулевой до четвертой вершины не пересчитывается, так 
  как четвертая вершина уже вошла во множество S. Прочерки в остальных ячейках 
  таблицы также означают отсутствие пересчета маршрутов для соответствующих вершин;</P>
<P>&#9674;&#9674;&#9674; 
  – 9 = min(11, 5+4), где 4 – вес пути из 3 вершины во вторую.</P>
<P><B><U>Комментарии</U><I>: 
  </I></B>В алгоритме Дейкстры на каждом шаге</P>
<P><I><B> S</B></I> – растущее 
  множество вершин, для которых уже найдены их подлинные стоимости;</P>
<P><I><B>w</B></I> – добавляемая 
  к множеству S вершина;</P>
<P><I><B>D[j]</B></I> – минимально 
  возможная стоимость маршрута следующего вида:</P>
<p><IMG SRC="img/05.gif" ></p>
<p>Рисунок 3.8</p>
<P><B><U> Замечание</U>:</B> 
  Алгоритм Дейкстры работает корректно, так как на каждом шаге стоимость каждой 
  вершины <IMG SRC="img/image189.gif" WIDTH=72 HEIGHT=21 align="texttop"> пересчитывается 
  по формуле <I>(3.1)</I>, что соответствует выбору из двух маршрутов – старого 
  (<img src="img/06.gif"> ) и нового (<img src="img/06.gif"> ).</P>
<P>Оценим <I>трудоемкость</I> 
  данного алгоритма:</P>
<P>В процессе 
  реализации алгоритма Дейкстры <I>n</I> раз выполняется цикл <I>While</I>. Внутри 
  цикла <I>While</I> имеется цикл <I>For</I>, в котором нам приходится пересчитывать 
  <I>n–1, n–2, n–3,…,1</I> значений. Каждое из них – минимум из двух чисел, одно 
  из которых – сумма двух слагаемых.</P>
<P>Следовательно, 
  получаем квадратичную трудоёмкость:</P>
<P><IMG SRC="img/image190.gif" WIDTH=274 HEIGHT=29>.</P>
<P>То есть алгоритм 
  Дейкстры в целом работает на порядок быстрее, чем алгоритм Форда-Беллмана.</P>
<P><B><U>Замечание</U>: 
  </B>Алгоритм Дейкстры может работать только с графами, для которых стоимости 
  переезда <IMG SRC="img/image191.gif" WIDTH=70 HEIGHT=21 align="texttop">. Алгоритм 
  Форда-Беллмана справляется с графами и с отрицательными стоимостями переезда, 
  но работает дольше.</P><br>
<a name=4 class="anchor"></a> 
<h3>3.4 Нахождение 
  диаметра, радиуса и центра графа</h3> 
<P>Определения:</P>
<P> <I>Диаметром 
  графа </I>(взвешенного) называется максимально возможное расстояние между вершинами.</P>
<P><IMG SRC="img/image192.gif" WIDTH=172 HEIGHT=26>– 
  максимальная стоимость маршрута <IMG SRC="img/image193.gif">.</P>
<P><I>Радиусом 
  графа</I> называется минимально возможный радиус круга (центр круга выбирается 
  среди всех вершин), внутри которого помещается весь граф. </P>
<P><IMG SRC="img/image194.gif" >,</P>
<P>где <IMG SRC="img/image195.gif">– 
  минимально возможный радиус круга (в который входит весь граф) с центром в вершине 
  <IMG SRC="img/image196.gif" WIDTH=24 HEIGHT=30><FONT SIZE=4>.</P>
<P> <I>Центр 
  графа</I> – та вершина <IMG SRC="img/image197.gif" WIDTH=23 HEIGHT=28>, для 
  которой достигается минимально возможный радиус круга: <IMG SRC="img/image198.gif" 8> 
  : <IMG SRC="img/image199.gif" >.</P>
<P>При применении алгоритма 
  Дейкстры и диаметр, и радиус графа можно найти за <IMG SRC="img/image200.gif" WIDTH=90 HEIGHT=29>операций, 
  где n<SUP>2</SUP> трудоёмкость однократного применения алгоритма Дейкстры.</P>
<P>Алгоритм 
  Дейкстры мы запускаем <I>n</I> раз: сначала от <I>v<SUB>0</SUB></I>, потом от 
  <I>v<SUB>1</SUB></I> и т.д. перебирая все возможные вершины <IMG SRC="img/image201.gif" WIDTH=14 HEIGHT=14>. 
  Получаем квадратную матрицу <IMG SRC="img/image202.gif" >, по которой мы за 
  <I>n<SUP>2</SUP></I> операций находим диаметр и радиус графа.</P><br>
<a name=5 class="anchor"></a>
<h3>3.5 Задача 
  об изоморфизме графов</h3>
<p> Определение: Два взвешенных 
графа <I>G</I><SUB>1</SUB> и <I>G</I><SUB>2</SUB> называются <I>изоморфными</I>, 
если существует взаимнооднозначное отображение вершин, сохраняющих расстояние, 
т.е. после перенумерации вершин графа <I>G</I><SUB>1</SUB> получаем ровно граф 
<I>G</I><SUB>2</SUB>.  
<P>Оценим трудоемкость этой задачи методом прямого перебора:</P>
<P>На входе имеем два графа из <I>n</I> вершин.</P>
<P>Существует всего <I>n!</I> различных перестановок 
  ( перенумераций ) для <I>n</I>-элементного массива и при каждой перенумерации 
  необходимо проверить <I>n<SUP>2</SUP></I> – попарных расстояний. Таким образом, 
  трудоемкость этих операций составит <IMG SRC="img/image203.gif" >.</P>
<P>Нетрудно заметить, что этот алгоритм не полиномиальный 
  и его трудоемкость велика. На данный момент не известны алгоритмы решения данной 
  задачи для графов произвольного вида за полиномиальное время, но и не доказано, 
  что такого алгоритма не существует.</P>
<P>В тоже время для графов некоторых специальных 
  видов (для деревьев) данные алгоритмы существуют.</P><br>
<a name=6 class="anchor"></a> 
<h3>3.6 Задача коммивояжера. Ее решение методом ветвей 
  и границ</h3> 
<P><I><U> Задача</U>: 
  Имеется взвешенный неориентированный связный граф. Необходимо найти гамильтонов 
  цикл наименьшей длины, т.е. нужно обойти все вершины графа, побывав в каждой 
  из них по одному разу, затратив как можно меньше денег.</I> </P>
<P>Оценим трудоемкость 
  методом прямого перебора. </P>
<P>Имеем <I>n! </I>всевозможных 
  маршрутов. Стоимость каждого маршрута – сумма <I>n </I>ребер. Следовательно, 
  </P>
<P><IMG SRC="img/image204.gif" WIDTH=86 HEIGHT=25></P>
<P><I>n!</I> 
  можно заменить <I>(n–1)!,</I> т.к. маршрут проходит через все вершины, и поэтому 
  в качестве стартовой мы можем взять вершину <I>v<SUB>1</SUB>,</I> располагая 
  оставшиеся вершины <I>(n–1)</I> произвольным образом.</P>
<P> <IMG SRC="img/image205.gif" WIDTH=149 HEIGHT=25> 
  – неполиномиальная.</P>
<P>Для более быстрого 
  решения нашей задачи существует метод ветвей и границ. На самом деле это целая 
  группа методов, они используются для решения множества задач. Их объединяет 
  общая идея, но в каждом случае реализация метода ветвей и границ своя. Впервые 
  этот метод был придуман для решения задачи коммивояжера.</P>
<P><B><U> Идея метода ветвей 
  и границ</U>: </B>Пусть нам необходимо найти минимум некоторой функции <IMG SRC="img/image206.gif" WIDTH=82 HEIGHT=22>. 
  Предположим, что у нас есть:</P>
<P>а) Алгоритм дробления множества 
  <I>D</I> на всё уменьшающиеся части (вплоть до одноэлементных множеств).</P>
<P>б) Для каждой 
  части <IMG SRC="img/image207.gif" WIDTH=20 HEIGHT=24>, полученной в результате 
  дробления, имеется некоторая оценка <IMG SRC="img/image208.gif" WIDTH=168 HEIGHT=29 align="absmiddle">. 
  Эта величина оценивает значение функции <I>f</I> на интервале <IMG SRC="img/image209.gif" WIDTH=24 HEIGHT=28> 
  снизу, причем на одноэлементных множествах эта оценка совпадает со значениями 
  функции <I>f</I>. </P>
<P>Тогда для 
  нахождения минимума поступаем следующим образом:</P>
<P>Возьмем 
  точку x из множества D (желательно, чтобы <I>f(x)</I> была как можно меньше). 
  Объявим f(x) рекордом r . Делим множество D на части: </P>
<I> 
<P>D</P>
</I> <I> 
<P>D<SUP>(1)</SUP><SUB>1 
  </SUB>D<SUP>(1)</SUP><SUB>2 </SUB>D<SUP>(1)</SUP><SUB>3 </SUB>D<SUP>(1)</SUP><SUB>4</SUB></P>
<P>H(D<SUP>(1)</SUP><SUB>1</SUB>)&lt;r 
  H(D<SUP>(1)</SUP><SUB>2</SUB>)&gt;r H(D<SUP>(1)</SUP><SUB>3</SUB>)=r H(D<SUP>(1)</SUP><SUB>4</SUB>)&lt;r</P>
</I> 
<P>где <I>f</I> – функция-оценка 
  минимума. </P>
<P>Для множества 
  <I>D<SUP>(1)</SUP><SUB>2</SUB></I> справедливо:</P>
<P><I> H(D<SUP>(1)</SUP><SUB>2</SUB>) 
  &gt; r, </I>тогда для всех <I> y<IMG SRC="img/image210.gif" WIDTH=13 HEIGHT=13> 
  D<SUP>(1)</SUP><SUB>2 </SUB> </I>выполняется<I> f(y) &#8805; H(D<SUP>(1)</SUP><SUB>2</SUB>) 
  &gt; r</I>,</P>
<P>следовательно, 
  на этом множестве мы минимума не достигнем, поэтому данное множество отбрасываем. 
  Таким образом, ветвь мы отрубаем тогда и только тогда, когда функция-оценка 
  минимума на этом множестве больше либо равна рекорда. Далее работаем с множествами 
  <I>D<SUP>(1)</SUP><SUB>1</SUB></I> и <I>D<SUP>(1)</SUP><SUB>4</SUB></I> , и, 
  не смотря на то, что множество <I>D<SUP>(1)</SUP><SUB>1</SUB> </I>кажется более 
  перспективным, может случиться так, что реальное значение минимума будет достигнуто 
  на <I>D<SUP>(1)</SUP><SUB>4</SUB></I> (так как мы не требовали, чтобы выполнялось 
  <I>H(D<SUP>(i)</SUP><SUB>k </SUB>) = min f(x)</I> , а <I>H(D<SUP>(i)</SUP><SUB>k</SUB> 
  </I> является лишь некоторой оценкой этого минимума снизу).</P>
<I> 
<P>H(D<SUP>(i)</SUP><SUB>k</SUB>) 
  &#8804; min f(x) , x <IMG SRC="img/image210.gif" WIDTH=13 HEIGHT=13> D<SUP>(i)</SUP><SUB>k</SUB></P>
</I> 
<P>Множество 
  <I>D<SUP>(1)</SUP><SUB>3</SUB></I> мы можем в процессе работы не рассматривать, 
  если нам достаточно найти хотя бы одну точку, в которой достигается минимум, 
  если же нам необходимо найти все точки, то множество <I>D<SUP>(1)</SUP><SUB>3</SUB></I> 
  считаем перспективным.</P>
<P><B><U>Замечание</U>: 
  </B>Подобное дробление множества <I>D</I> продолжаем до тех пор, пока не доберемся 
  до одноэлементных множеств (нижнего этажа дерева).</P>
<p><IMG SRC="img/image211.gif" WIDTH=250 HEIGHT=160> 
  </p>
<p>Рисунок 3.9 
  Дробление множества, где</p>
<UL>
  <P> 
  <LI>перспективное множество</LI>
  </P>  
</UL>
<P><IMG SRC="img/image64.gif" WIDTH=12 HEIGHT=22><IMG SRC="img/image212.gif" WIDTH=17 HEIGHT=17> 
  неперспективное множество</P>
<P>При этом возможны два варианта 
  дробления:</P>
<I><U> 
<P>Схема одновременного ветвления:</P>
</U></I> 
<P>На каждом шаге мы работаем 
  со всеми перспективными множествами:</P>
<p><IMG SRC="img/image213.gif" ></p>
<p> нижний этаж 
  – одноэлементные множества</p>
<P>Рисунок 3.10 
  Одновременное дробление</P>
<I><U> 
<P>Схема одностороннего ветвления:</P>
</U></I> 
<P>Отличие 
  этой схемы от предыдущей заключается в том, что на каждом шаге мы работаем только 
  с одним перспективным множеством, а не со всеми сразу, как в схеме одновременного 
  ветвления (см. рис.3.11).</P>
<P>Здесь:</P>
<P><IMG SRC="img/image214.gif" WIDTH=25 HEIGHT=27>&nbsp; 
  перспективное множество</P>
<P><IMG SRC="img/image215.gif" WIDTH=22 HEIGHT=22>&nbsp; 
  неперспективное множество</P>
<P><IMG SRC="img/image216.gif" WIDTH=17 HEIGHT=17>&nbsp; 
  отложенное перспективное множество</P>
<P><IMG SRC="img/image217.gif" WIDTH=23 HEIGHT=20>&nbsp; 
  ветвь, ставшая неперспективной после обновления рекорда</P>
<P><IMG SRC="img/image218.gif" ></P>
<P>Рисунок 3.11 
  Одностороннее дробление</P>
<P>По ходу 
  дробления на каждом шаге из всех множеств выбирается самое перспективное – то, 
  на котором меньше всего оценка <I>f</I>. С ним и будем работать дальше. Рассмотрение 
  остальных перспективных множеств пока отложим. Эта схема предпочтительнее, т.к. 
  при ее применении мы быстрее доберемся до нижнего этажа, где сможем обновить 
  рекорд, а после его обновления многие множества, ранее перспективные, при новом 
  рекорде могут перейти в разряд неперспективных, и их мы рассматривать вообще 
  не будем. Таким образом, трудоемкость схемы одностороннего ветвления существенно 
  меньше схемы одновременного ветвления.</P>
<I><U> 
<P>Алгоритм 
  одностороннего ветвления:</P>
</U></I> 
<P>На каждом 
  шаге оставляем в работе только одно, самое перспективное множество. Таким образом 
  доходим до нижнего этажа дерева, при этом все находящиеся на нем множества станут 
  одноэлементными. Обновляем рекорд. Выкидываем уже неперспективные отложенные 
  ветви. Среди оставшихся перспективных ветвей выбираем самую перспективную (либо 
  по оценке <I>f</I>, либо по уровню, на котором она расположена в дереве – чем 
  ближе к нижнему этажу, тем перспективнее отложенная ветвь).</P>
<P>Подобную 
  процедуру подъема и спуска продолжаем до тех пор, пока не останется ни одной 
  перспективной ветви.</P>
<U><I> 
<P>Применение 
  метода ветвей и границ для решения задачи коммивояжера.</P>
</I></U> 
<P>В нашем 
  случае исходное множество <I>D</I> – множество всевозможных маршрутов, проходящих 
  по всем вершинам графа (так называемых гамильтоновых циклов), для определенности 
  стартующих из точки 0. Напомним, что гамильтонов цикл должен содержать все вершины 
  графа, причем, переходя по его ребрам, можно обойти все вершины, побывав в каждой 
  только по одному разу.</P>
<P>В предложенной 
  схеме дробления будут возникать подмножества <I>D</I> следующего вида:</P>
<p><IMG SRC="img/image219.gif" ></P>
<P>Множество 
  <IMG SRC="img/image220.gif" > состоит из всевозможных маршрутов, у которых <IMG SRC="img/image221.gif" > 
  – первоначальный участок, а следующий переход из вершины <IMG SRC="img/image222.gif" WIDTH=21 HEIGHT=28> 
  мы можем совершить в любую вершину, кроме указанных в фигурных скобках вершин 
  <IMG SRC="img/image223.gif" WIDTH=60 HEIGHT=28>. Также мы не можем идти в вершины 
  <IMG SRC="img/image224.gif" >, так как тогда маршрут будет уже не гамильтонов.</P>
<P>Составим 
  оценку <I>f </I>для множества <IMG SRC="img/image225.gif"> следующего вида:</P>
<P><IMG SRC="img/image226.gif" ></P>
<P>где </P>
<P> <IMG SRC="img/image227.gif" WIDTH=40 HEIGHT=24> 
  – стоимость выхода (выезда) из вершины <IMG SRC="img/image228.gif" WIDTH=13 HEIGHT=16> 
  (т.е. минимально возможная цена, за которую мы можем выехать в какую-либо другую 
  допустимую вершину),</P>
<P> <IMG SRC="img/image229.gif" WIDTH=40 HEIGHT=22> 
  – минимально возможная стоимость въезда в вершину <IMG SRC="img/image230.gif" > 
  после уже уплаченных стоимостей выездов.</P>
<P><I><B>Пример: </B></I>Пусть 
  у нас имеется гамильтонов цикл в ориентированном графе (для орграфа матрица 
  стоимости ребер не симметрична относительно своей главной диагонали). По главной 
  диагонали расположены бесконечности, а не нули, потому что в гамильтоновом цикле 
  петли запрещены.</P>
<P><IMG SRC="img/image231.gif" WIDTH=205 HEIGHT=190></P>
<P>Имеем первоначальный 
  маршрут: <I>D = [ (2,5,0),{1} ].</I></P>
<P>Таким образом, 
  из вершины 0 мы можем идти в любую, кроме 1(так как она запрещенная), 2 и 5 
  (так как их уже прошли). </P>
<P>Вычисляем 
  оценку <I>Н</I>. Для этого:</P>
<p>
  1. Вычеркиваем из имеющейся 
    матрицы 2 и 5 строки, так как стоимости ребер, по которым можно попасть во 
    2 и 5 вершины, нам не понадобятся, в эти вершины мы уже въезжали и больше 
    туда не собираемся.</p>
  <p>2. Вычеркиваем 5 и 0 столбцы, 
    так как уже въезжали в вершины 5 и 0.</p>
  <P><IMG SRC="img/image232.gif" WIDTH=205 HEIGHT=190></P>
  <p>3. Получилась матрица:</p>

<P><img src="img/image233.gif" width=157 height=131></P>
<P>Стоимость 
  переезда из 0 в 1 полагаем равной бесконечности, так как он запрещен. В каждой 
  строке находим минимальный элемент (минимальную стоимость выезда из вершин 0,1,3 
  и 4), т.е. находим &#945;:</P>
<P><IMG SRC="img/image234.gif" WIDTH=182 HEIGHT=132><IMG SRC="img/image235.gif" WIDTH=16 HEIGHT=114></P>
<P> “Уплачиваем” 
  найденные стоимости выездов, т.е. вычитаем из каждого элемента строки минимальный 
  элемент данной строки. Стоимости выездов “уплачены”, однако мы еще должны заехать 
  в вершины 1, 2, 3, 4. находим для них оценку <IMG SRC="img/image236.gif" WIDTH=16 HEIGHT=21>.</P>
<P><IMG SRC="img/image237.gif" WIDTH=157 HEIGHT=133></P>
<P> <IMG SRC="img/image238.gif" WIDTH=148 HEIGHT=33></P>
<P>Итак, оценка</P>
<P> <IMG SRC="img/image239.gif" WIDTH=586 HEIGHT=22></P>
<P><SUB> из 
  первоначальной матрицы</SUB></P>
<P> = 3+3+( 
  6+3+4+2 )+( 0+0+1+0 ) = 22.</P>
<P>То есть, 
  проехав по любому маршруту из множества <IMG SRC="img/image240.gif" >, мы не 
  можем потратить менее 22 долларов.</P>
<P>Осталось 
  записать схему возможных вариантов дробления маршрутов D.</P>
<P>Рассмотрим 
  два варианта этой схемы на примере пятиэлементного множества:</P>
<I> 
<P>Первый вариант:</P>
</I> 
<P><IMG SRC="img/image241.gif" width="759" height="255" ></P>
<P>Рисунок 3.12</P>
<P>Тут не возникает 
  запретных вершин.</P>
<I> 
<P>Второй вариант:</P>
</I> 
<P>При этой 
  схеме дробления на каждом этапе ветка делится на две новые ветви, но также возникают 
  и запретные вершины.</P>
<P></P>
<P><IMG SRC="img/image242.gif" ></P>
<P>Рисунок 3.13</P>
<P>и т.д.</P>
<P><B><U>Замечание:</U> 
  </B>Обычно метод ветвей и границ позволяет существенно уменьшить объем перебора. 
  Однако это справедливо не для каждой задачи, например для задачи коммивояжера 
  до сих пор неизвестен алгоритм, который гарантированно бы решал ее за полиномиальное 
  время. Впрочем, для большинства графов он дает существенный выигрыш по сравнению 
  с прямым перебором.</P>
<B> 
<P>Домашнее задание №1 (А, 
  Б, В):</P>
</B> 
<P>А) Найти 
  остов минимального веса для связного взвешенного неориентированного графа, заданного 
  матрицей весов дуг, соединяющих всевозможные пары вершин (0 означает, что соответствующей 
  дуги нет).</p>
<p> <IMG SRC="img/image243.gif" WIDTH=165 HEIGHT=166></p>
<P>Б) Найти 
  кратчайшие расстояния от второй до всех остальных вершин графа (нумерация вершин 
  начинается с 0), для связного взвешенного графа, заданного матрицей весов дуг, 
  соединяющих всевозможные пары вершин (0 означает, что соответствующей дуги нет)</P>
<P>Б1) с помощью алгоритма 
  Форд-Беллмана;</P>
<P>Б2) с помощью алгоритма 
  Дейкстры.</P>
<P>Матрица стоимостей:</P>
<P><IMG SRC="img/image244.gif" WIDTH=165 HEIGHT=166></P>
<P>В) Определить 
  нижнюю оценку стоимости любого маршрута из множества D&nbsp;=[(4,0,3),{1,5}] 
  для задачи коммивояжера. </P>
<P>Матрица стоимостей переездов: 
  </P>
<B><I> 
<P><IMG SRC="img/image245.gif" WIDTH=182 HEIGHT=166></P>
<br><br>
<!--конец-->
      
				

				</div>
			</div>
			
      </div>
    </div>
  </div>
	
	<!--Меню навигации по Темам -->	
	<div aria-label="..." class = "nav-menu">
	 <ul class="pager background-transition-slow">
		 <li title="Наверх" style = "margin-right:15px;	"><a class = "glyphicon glyphicon-menu-up page-scroll" href="#page-top"></a></li>
		 <li title="К предыдущей лекции"><a class = "glyphicon glyphicon-menu-left page-scroll" href="t2.htm"></a></li>
		 <li title="В содержание"><a class = "glyphicon glyphicon-list-alt" href="lec_index.htm"></a></li>
		 <li title="К следующей лекции"><a class = "glyphicon glyphicon-menu-right page-scroll" href="t4.htm"></a></li>
	 </ul>
	</div>
	<!---->
	
	</div>
  <!-- jQuery -->
  <script src="../lib/js/jquery.js"></script>

  <!-- Bootstrap Core JavaScript -->
  <script src="../lib/js/bootstrap.min.js"></script>

  <!-- Scrolling Nav JavaScript -->
  <script src="../lib/js/jquery.easing.min.js"></script>
  <script src="../lib/js/scrolling-nav.js"></script>

</body>

</html>

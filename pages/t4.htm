<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="do.sibsutis.ru">

  <title>Тема 1. Конспект лекций</title>
	
	<link rel="icon" type="image/png" href="../lib/css/favicon.png">
  <!-- Bootstrap Core CSS -->
  <link href="../lib/css/bootstrap.css" rel="stylesheet">
	
  <!-- Custom CSS -->
  <link href="../lib/css/scrolling-nav.css" rel="stylesheet">

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
  <![endif]-->
</head>

<!-- The #page-top ID is part of the scrolling feature - the data-spy and data-target are part of the built-in Bootstrap scrollspy function -->

<body id="page-top" data-spy="scroll" data-target=".navbar-fixed-top">
  <!-- Navigation -->
<nav class="navbar navbar-default navbar-fixed-top">
 <div class="container">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
   <li class="hidden"> <a class="page-scroll" href="#page-top"></a> </li>
	 
	 <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
   </button>
	 
   <a class="navbar-brand " href="../index.htm"> 
  <text class = "hidden-xs">Теория сложности вычислительных процессов и структур</text> 
  <text class = "visible-xs">ТСВП и С</text>
	 </a>
  </div>

  <!-- Collect the nav links, forms, and glyphicon glyphicon-list-alt content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
   
	 <!-- <ul class="nav navbar-nav">
		<li><a href="#"></a></li> 
   </ul> -->
	
   <ul class="nav navbar-nav navbar-right">
    <li class="dropdown">
		<button type="button" class="navbar-toggle dropdown-toggle hidden-xs" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
		</button>	   
		<a class = "dropdown-toggle visible-xs" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Материалы</a>
     <ul class="dropdown-menu">
    <li><a href="../index.htm">Аннотация курса</a></li>
      <li role="separator" class="divider"></li>
      <li><a href="lec_index.htm">Теория</a></li>
	<!--li><a href="Posobie.htm">Учебное пособие</a></li-->

        <li><a href="labs.htm">Лабораторные работы</a></li>   
    <li><a href="c_work.htm">Контрольная работа</a></li>
      <li role="separator" class="divider"></li>
       <li><a href="lit.htm">Литература</a></li>
      <!--li><a href="q.htm">Вопросы для самопроверки</a></li-->			
     </ul>
 </li>
 </ul>
  </div><!-- /.navbar-collapse -->
 </div><!-- /.container-fluid -->
</nav>


  <div id="intro" class="section content-section ">
    <div class="container">
       <div class="row">
        <div class="col-lg-12">	


<!-- содержание -->	
<div class="page-header">				

<h3><a href="#">4 ЗАДАЧИ ДИНАМИЧЕСКОГО ПРОГРАММИРОВАНИЯ</a></h3>
<a href="#1" class=punkt>4.1 Задача динамического программирования. Её решение методом динамического программирования</a><br>

<a href="#2" class=punkt>4.2 Задача об оптимальном наборе самолетом скорости и высоты</a><br>

<a href="#3" class=punkt>4.3 Задача грабителя (задача о рюкзаке)</a><br>

<a href="#4" class=punkt>4.4 Задача о перемножении матриц</a><br>

</div>
<!--начало-->
<a name=1 class="anchor"></a>

<h3>4.1 Задача динамического 
  программирования. Её решение методом динамического программирования</h3>
<P><I><strong>Определение:</strong> Задача динамического 
  программирования (ДП)</I> – это задача оптимального управления некоторым многошаговым 
  процессом.</P>
<P>Подобных задач, равно как и методов их решения, 
  существует великое множество. Изобретаются они в каждом конкретном случае индивидуально, 
  но все объединены общей идеей решения – так называемого метода решения задачи 
  про чайник: чтобы вскипятить воду, нужно налить её в чайник, поставить его на 
  плиту, включить плиту и т.д. Если же вода в чайник уже налита, то нужно её вылить. 
  А что делать дальше, мы уже знаем. Таким образом, в процессе решения мы сводим 
  задачу к той, решать которую уже научились на предыдущем шаге.</font></P>
<p>Рассуждения при этом проводятся примерно следующие:</font></P>
<p>Нам необходимо найти оптимальное значение в 
  конце маршрута. Если бы мы знали оптимальное решение для всех предыдущих этапов, 
  то нашли бы решение для последнего. Чтобы найти решение для предпоследнего этапа, 
  мы должны знать решение для второго с конца этапа, и т.д. То есть разрабатывается 
  метод динамического программирования с конца. Реализуется же он сначала: высчитываем 
  оптимальные значения с самого начала и находим оптимальную стоимость. После 
  этого необходимо найти собственно оптимальный маршрут. Его находим с конца.</font></P>
<p><B><U> Задача</U>: </B>Рассмотрим задачу оптимального 
  управления многошаговым процессом. Над ребрами данного графа проставлены стоимости 
  переходов из одной вершины в другую. Необходимо найти путь, по которому с минимальными 
  затратами можно попасть из S<SUP>(0)</SUP> в S<SUP>(5) </SUP>(см. рисунок 4.1).</font></P>
<B> 
<P><IMG SRC="img/image246.gif" width="907" height="378" ></font></P>
</B></font> 
<P>Рисунок 4.1 
  Исходный граф</font></P>
<p><B><U>Идея 
  решения</U>: </B>В принципе мы умеем решать подобные задачи по алгоритму Дейкстры 
  и Форда-Беллмана. Попробуем теперь решить эту задачу методом динамического программирования. 
  Он изобретается с конца. Нам необходимо найти минимально возможную сумму, имея 
  которую, мы можем добраться до <I>S<SUP>(5)</SUP></I> .</font></P>
<p>Рассуждаем 
  так: если бы мы знали “стоимости” всех вершин, из которых мы можем попасть в 
  S<SUP>(5)</SUP> (то есть вершин <IMG SRC="img/image247.gif" >), то мы бы нашли 
  стоимости всех вершин S<SUP>(5)</SUP> (для этого к стоимости вершин из S<SUP>(4)</SUP> 
  прибавляем стоимости переездов и выбираем минимум из получившихся сумм). Чтобы 
  найти стоимости <I>S<SUP>(4)</SUP></I> мы должны знать стоимости <I>S<SUP>(3)</SUP></I> 
  и т.д. Так спускаемся до вершины <I>S<SUP>(0)</SUP>,</I> стоимость которой равно 
  нулю.</font></P>
<p>Итак, <IMG SRC="img/image248.gif" align="absmiddle"></font></P>
<p> здесь <IMG SRC="img/image249.gif" WIDTH=56 HEIGHT=32> 
  – минимально возможная сумма денег, имея которую мы можем добраться от <IMG SRC="img/image250.gif" > 
  до <IMG SRC="img/image251.gif" >.</font></P>
<p>Имеем:</font></P>
<P><IMG SRC="img/image252.gif" width="924" height="378" ></font></P>
<P>Рисунок 4.2 
  Здесь<IMG SRC="img/image253.gif" WIDTH=35 HEIGHT=34 align="absmiddle">– полученные 
  стоимости вершин<SUP>.</SUP></font></P>
<p>Реализация 
  метода ДП происходит от начала к концу (то есть слева направо в нашем случае). 
  Самый внешний цикл – по <I>i; </I>в нём<I> </I>в прямом порядке перебираем уровни 
  вершин. Следующий по вложенности цикл – по <I>j</I>; в нём перебираем вершины 
  одного уровня. Самый внутренний цикл – по <I>k.</I> Изменение направления прохода 
  двух вложенных циклов не повлияет на конечный результат.</font></P>
<p>Последний 
  этап – восстановление оптимального пути – реализуется из конца в начало. Для 
  этого смотрим, из какой вершины предыдущего уровня была достигнута стоимость 
  нашей вершины, постепенно продвигаясь справа налево.</font></P>
<p><IMG SRC="img/image254.gif" width="929" height="378" ></font></P>
<P>Рисунок 4.3 Восстановление оптимального пути</P>
<P></P>
<a name=2 class="anchor"></a>
<h3>4.2 
  Задача об оптимальном наборе самолетом скорости и высоты</h3>
<p><B><U>Задача</U>: 
  </B><I>Необходимо, имея стартовую нулевую скорость v и стартовую нулевую высоту 
  h, набрать некоторую скорость V и высоту H, минимизировав при этом суммарные 
  затраты топлива.</I> </font></P>
<I> 
<p>Если в какой-то 
  момент времени t мы увеличиваем скорость на dv, а высоту на dh, то затраты горючего 
  на это изменение могут быть определены по формуле:</font></P>
<P><IMG SRC="img/image255.gif" ></font></P>
<p>где v(t) 
  и h(t) – скорость и высота в момент времени t.</font></P>
<p><IMG SRC="img/image256.gif" > 
  и <IMG SRC="img/image257.gif" > – коэффициенты пропорциональности затрат топлива.</font></P>
</I> 
<p><B><U> Идея 
  решения</U>: </B>Нам необходимо минимизировать интеграл, выбирая оптимальный 
  вариант набора скорости и высоты (ищем оптимальное управление):</font></P>
<P><IMG SRC="img/image258.gif" ></font></P>
<p>Дискретизируем 
  эту задачу. Для этого разобьем весь участок приращения скорости и высоты на 
  несколько меньших интервалов:</font></P>
<P><IMG SRC="img/image259.gif" WIDTH=439 HEIGHT=323></font></P>
<P>Рисунок 4.4 
  Дискретизация исходной задачи</font></P>
<p>Заполняем 
  стоимости, начиная с левого нижнего угла, и записываем их в левый сектор круга. 
  Аналогично считаем стоимости вершин с правого верхнего угла и записываем их 
  в правый сектор. Глядя на полученные стоимости, восстанавливаем оптимальный 
  путь: 87 получили из 79 + 8; 79 из 70 + 9 и т.д.</font></P>
<U> 
<P><B>Комментарии:</B></font></P>
</U> 
<p>&#9679; 
  В принципе, при восстановлении оптимального пути, возможно ветвление маршрута 
  (когда минимум получен на пути не из одной, а из большего количества вершин).</font></P>
<p>&#9679; 
  Все вершины графа разбиваются на группы состояний по диагоналям. Но в группу 
  S<SUP>(i)</SUP> мы попадаем не только из S<SUP>(i– 1)</SUP>, но и из S<SUP>(i–2)</SUP>.</font></P>
<p>&#9679; 
  При проходе слева направо и справа налево, как и следовало ожидать, стоимость 
  пути одинакова и равна 87. В каждом кружке сумма чисел больше либо равна 87. 
  Причем сумма равна 87 в кружках, лежащих на оптимальном пути, а для остальных 
  она превышает 87. В каждом кружке – левое число – стоимость маршрута из левого 
  нижнего угла до данного кружка. Правое число – стоимость маршрута из правого 
  верхнего угла до данного кружка.</font></P>
<a name=3 class="anchor"></a>
<h3>4.3 
  Задача грабителя (задача о рюкзаке)</h3>
<P><U><strong>Задача</strong></U>: 
  Имеется склад, на котором есть некоторый ассортимент товаров. Запас каждого 
  товара считается неограниченным. Товары имеют две характеристики: m<SUB>i</SUB> 
  – масса, c<SUB>i</SUB> – стоимость; <IMG SRC="img/image260.gif" WIDTH=49 HEIGHT=26>.</font></P>
<P>Необходимо выбрать набор 
  товаров так, чтобы его суммарная масса не превосходила заранее фиксированную 
  массу М (т.е. <IMG SRC="img/image261.gif" >), и стоимость набора была как можно 
  больше (<IMG SRC="img/image262.gif" >).</font></P>
<p><B><U> Идея 
  решения</U>: </B>Считаем, что все массы m<SUB>i</SUB> целочисленные. Решим эту 
  задачу методом динамического программирования. Изобретаем метод, т.е. формулу:</font></P>
<p>Нам необходимо 
  найти <IMG SRC="img/image263.gif" WIDTH=49 HEIGHT=24>, т.е. максимально возможную 
  сумму <IMG SRC="img/image264.gif" WIDTH=22 HEIGHT=26> при заданном <I>М</I>. 
  Предположим, что к этому моменту мы знаем, как решать эту задачу для всех меньших 
  значений грузоподъемности. Тогда смотрим, какой товар мы положили в рюкзак последним. 
  Если это был первый товар стоимостью с<SUB>1</SUB>, то мы должны оптимизировать 
  стоимость рюкзака при грузоподъемности <IMG SRC="img/image265.gif" >. Если это 
  был второй товар стоимостью с<SUB>2</SUB> , то оптимизация при грузоподъемности 
  <IMG SRC="img/image266.gif">, и т.д. Среди всех этих величин выбираем максимальную.</font></P>
<p>Таким образом, 
  получаем формулу: <img src="img/image267.gif" 9></font></P>
<P><I><B> Пример: </B></I>Рассмотрим 
  решение этой задачи при следующем наборе товаров:</font></P>
<P><I> m: </I>3 5 8 – массы 
  товаров,</font></P>
<P> <I>c: </I>8 14 23 – стоимости 
  товаров.</font></P>
<B><I> 
<P>Решение: </font></P>
</I></B> 
<P>Вычислим последовательно:</font></P>
<P><I>f(0)=0; f(1)=0; f(2)=0; 
  f(3)=8; f(4)=8;</I></font></P>
<P><I>f(5)= 14 = max( f(5–3)+8; 
  f(5–5)+14; f(5–8)+23);</I>–не рассматриваем при поиске максимума, так как <I>f(–3)</I> 
  не определена.</font></P>
<I> 
<P>f(6)=16; f(7)=16; f(8)= 
  23; f(9)= 24 =max( f(9–3)+8; f(9–5)+14; f(9–8)+23 );</font></P>
<P>f(10)=28; f(11)=31; f(12)=32; 
  f(13)= 37 =max( f(13–3)+8; </font></P>
<P>f(13–5)+14; f(13–8)+23 )</font></P>
</I> 
<P>Оценим трудоемкость решения 
  задачи о рюкзаке методом ДП:</font></P>
<p>Для применения 
  метода ДП все массы должны быть целочисленные ( а стоимости – необязательно). 
  Тогда, если <I>k</I> – количество видов товаров, <I>m</I> – грузоподъемность, 
  то имеем <I>m</I> шагов внешнего цикла (по грузоподъемности) и на каждом шаге 
  находим максимум среди <I>k</I> чисел, каждое из которых является суммой двух 
  слагаемых. В итоге получаем трудоемкость: <I>T = m·k.</I></font></P>
<a name=4 class="anchor"></a>
<h3>4.4 Задача 
  о перемножении матриц</h3>
 
<p>Как известно 
  из высшей математики, умножение матриц ассоциативно, то есть результат перемножения 
  зависит только от порядка матриц и не зависит от расстановки скобок: </font></P>
<I> 
<P>(A*B)*C = 
  A*(B*C).</font></P>
</I> 
<p>Результат 
  перемножения от расстановки скобок не зависит, зато трудоемкость этого перемножения 
  при разных расстановках скобок может отличаться существенно.</font></P>
<p>Оценим трудоемкость 
  умножения двух матриц<I> A(p&#215;q) </I>и<I> B(q&#215;>r)</I>: </font></P>
<I> 
<P> C(p&#215;r)=A(p&#215;q)*B(q&#215;r),</font></P>
</I> 
<P>каждый элемент 
  матрицы <I>С(p&#215;r) </I>есть сумма <I>q</I> попарных произведений.</font></P>
<p>Трудоемкость 
  перемножения двух матриц: <I>Т = p&#8729;q&#8729;r.</I></font></P>
<P><B> Пример: </B>Рассмотрим 
  пример перемножения матриц разными способами:</font></P>
<p>Пусть имеется 
  четыре матрицы разных размерностей:</font></P>
<p>M<SUB>1</SUB>[10&#215;20] 
  , M<SUB>2</SUB>[20&#215;50] M<SUB>3</SUB>[50&#215;1], M<SUB>4</SUB>[1&#215;100].</font></P>
<B> 
<p>Решение: 
  </font></P>
</B> 
<p>Рассмотрим 
  умножение матриц в следующем порядке: </font></P>
<I> 
<p> М<SUB>1</SUB> 
  &#8729; (М<SUB>2</SUB> &#8729; (М<SUB>3</SUB> &#8729; М<SUB>4</SUB>) )</font></P>
</I> 
<P> [50<I>&#215;</I>1] &#8729; 
  [1<I>&#215;</I>100]=[50<I>>&#215;</I>100] трудоёмкость 50&#8729;1&#8729;100 
  = 5000 </font></P>
<P>[20<I>>&#215;</I>>50] &#8729; 
  [50<I>&#215;</I>100]=[20<I>&#215;</I>100] трудоёмкость 20&#8729;100&#8729;50 
  = 100&nbsp;000 125&nbsp;000 </font></P>
<P>[10<I>&#215;</I>20] &#8729; 
  [20<I>>&#215;</I>100]=[10&#215;100] &#242;рудоёмкость 10&#8729;20&#8729;100 
  = 20 000 операций</font></P>
<p>Рассмотрим 
  другой вариант умножения матриц</font></P>
<I> 
<P>(М<SUB>1</SUB> &#8729; (М<SUB>2</SUB> 
  &#8729; М<SUB>3</SUB>) ) &#8729; М<SUB>4</SUB></font></P>
<P></P>
</I> 
<P>[20<I>&#215;</I>50] &#8729; 
  [50><I>&#215;</I>1]=[20<I>>&#215;</I>>1] трудоёмкость. 20&#8729;50&#8729;1=1000</font></P>
<P>[10<I>&#215;</I>20] &#8729; 
  [20<I>&#215;</I>1]=[10<I>&#215;</I>1] трудоёмкость 10&#8729;20&#8729;1=200 2200 
  операций </font></P>
<p>[10<I>&#215;</I>1] 
  &#8729; [1<I>&#215;</I>100]=[10<I>&#215;</I>100] трудоёмкость 10&#8729;1&#8729;100=1000</font></P>
<p> При умножении 
  вторым способом действий потребовалось значительно меньше (2200 против 125&nbsp;000). 
  Придумаем формулу метода ДП применительно к данной задаче:</font></P>
<p>Допустим, 
  нам необходимо оптимальным образом перемножить 5 матриц, i-тая матрица имеет 
  размерность [r<SUB>i–1</SUB>&#215;r<SUB>i</SUB>]. Смотрим, где стояла последняя 
  пара скобок : существует 4 варианта:</font></P>
<p> (М<SUB>1</SUB>)&#215; 
  (М<SUB>2</SUB>&#8729;М<SUB>3</SUB>&#8729;М<SUB>4</SUB>&#8729;М<SUB>5</SUB>) 
  (1)</font></P>
<p> [r<SUB>0</SUB><I>&#215;</I>r<SUB>1</SUB>] 
  [r<SUB>1</SUB><I>>&#215;</I>>r<SUB>5</SUB>]</font></P>
<p> (М<SUB>1</SUB>&#8729;М<SUB>2</SUB>)&#215; 
  (М<SUB>3</SUB>&#8729;М<SUB>4</SUB>&#8729;М<SUB>5</SUB>) (2)</font></P>
<p> [r<SUB>0</SUB><I>&#215;</I>>r<SUB>2</SUB>] 
  [r<SUB>2</SUB><I>&#215;</I>r<SUB>5</SUB>]</font></P>
<p><I> (М<SUB>1</SUB>&#8729;М<SUB>2</SUB>&#8729;М<SUB>3</SUB>)&#215; 
  (М<SUB>4</SUB>&#8729;М<SUB>5</SUB>)</I> (3)</font></P>
<p> [r<SUB>0</SUB><I>&#215;</I>>r<SUB>3</SUB>] 
  [r<SUB>3</SUB><I>&#215;</I>r<SUB>5</SUB>]</font></P>
<p><I> (М<SUB>1</SUB>&#8729;М<SUB>2</SUB>&#8729;М<SUB>3</SUB>&#8729;М<SUB>4</SUB>)&#215; 
  (М<SUB>5</SUB>)</I> (4)</font></P>
<p> [r<SUB>0</SUB><I>&#215;</I>r<SUB>4</SUB>] 
  [r<SUB>4</SUB><I>&#215;</I>r<SUB>5</SUB>] </font></P>
<p>При первом 
  варианте расстановки скобок нам потребуется </font></P>
<p><I> f(1,1) 
  + f(2,5) + r<SUB>0</SUB>r<SUB>1</SUB>r<SUB>5</SUB></I> операций.</font></P>
<p>Здесь <I>f(k,l)</I> 
  – минимальное количество действий, за которое можно вычислить произведение матриц 
  с <I>k</I>-той по <I>l</I>-тую.</font></P>
<p>Для последующих 
  трех вариантов:</font></P>
<P><IMG SRC="img/image268.gif"></font></P>
<p>операций 
  соответственно.</font></P>
<p>Здесь <I>f(k,p)</I> 
  – минимальное количество действий, за которое можно вычислить произведение матриц 
  с <I>k</I>-той по <I>p</I>-тую.</font></P>
<p>Выбираем 
  минимум среди всех этих чисел и получаем общую формулу:</font></P>
<P><IMG SRC="img/image269.gif" ></font></P>
<p><B><U>Замечание</U>: 
  </B>В отличие от задачи о рюкзаке, где была динамика по одному параметру (грузоподъемности), 
  здесь динамика по двум параметрам: начало и конец блока перемножаемых матриц.</font></P>
<p>Итак, в 
  окончательном виде эта задача решается с помощью следующего алгоритма:</font></P>
<p>1) Заполняем 
  трудоемкости матриц:</font></P>
<p> Трудоемкости 
  на главной диагонали равны 0:</font></P>
<p> for<I> 
  i:=1</I> to <I>n</I> do <I>f(i,i)</I>:=0;</font></P>
<p>2) Внешний 
  цикл по t – длине перемножаемого блока;</font></P>
<p> Средний 
  цикл по k – местоположению блока;</font></P>
<p> Внутренний 
  – поиск минимума по j. </font></P>
<p> for <I>t:=1</I> 
  to <I>n–1</I> do</font></P>
<p> for <I>k:=1</I> 
  to <I>n–t</I> do</font></P>
<P> <IMG SRC="img/image270.gif" WIDTH=482 HEIGHT=38>.</font></P>
<p>Для матриц 
  М<SUB>1</SUB>, М<SUB>2</SUB>, М<SUB>3</SUB>, М<SUB>4</SUB> из рассмотренного 
  выше примера расставим скобки оптимальным образом.</font></P>
<P ALIGN="left"><I> f</I>(1,1) 
  <I>f</I>(1,2) <I>f</I>(1,3) <I>f</I>(1,4)</font></P>
<p> <I>f</I>(2,2) 
  <I>f</I>(2,3) <I>f</I>(2,4)</font></P>
<p> <I>f</I>(3,3) 
  <I>f</I>(3,4)</font></P>
<p> <I>f</I>(4,4)</font></P>
<p>Итак, заполняем 
  такую матрицу в следующем порядке:</font></P>
<P><IMG SRC="img/image271.gif" ></font></P>
<p>После вычисления 
  оптимальных трудоемкостей восстанавливаем оптимальную расстановку скобок;</font></P>
<p>Смотрим, 
  где достигнут минимум в <IMG SRC="img/image272.gif" WIDTH=46 HEIGHT=22>. Он 
  достигнут в <IMG SRC="img/image273.gif" WIDTH=185 HEIGHT=22>. Следовательно, 
  последними скобками будут <I>(М<SUB>1</SUB> М<SUB>2</SUB> М<SUB>3</SUB>) (М<SUB>4</SUB>).</I></font></P>
<p>Далее смотрим, 
  где достигнут минимум в <IMG SRC="img/image274.gif" WIDTH=46 HEIGHT=22>. Он 
  достигнут в<img src="img/image275.gif" width=176 height=22> . Т.е. следующими 
  скобками будут <I>(М<SUB>1</SUB> (М<SUB>2</SUB> М<SUB>3</SUB>)) М<SUB>4</SUB>.</I></font></P>
<p>Т.к. у нас 
  3 вложенных цикла, длина каждого порядка <I>n </I>(<I>n </I>– количество перемножаемых 
  матриц), то трудоемкость решаемой задачи методом ДП <IMG SRC="img/image276.gif" WIDTH=74 HEIGHT=26></font></P>
<p>При решении 
  этой задачи методом прямого перебора получаем не полиномиальную трудоемкость, 
  а намного большую. То же самое получаем и для задачи о рюкзаке: её решение методом 
  динамического программирования имеет полиномиальную трудоемкость (2 вложенных 
  цикла), а методом прямого перебора получаем неполиномиальную трудоемкость.</font></P>
<B> 
<P>Домашнее задание №2 (А, 
  Б)</font></P>
</B> 
<p>А) Задача 
  грабителя (о рюкзаке). Имеется склад, на котором присутствует ассортимент товаров 
  (каждого товара неограниченный запас). У каждого товара своя стоимость C<SUB>i</SUB> 
  и масса m<SUB>i </SUB>. Выбрать набор товаров так, чтобы его суммарный вес не 
  превышал заданную грузоподъемность М, и суммарная стоимость этого набора товаров 
  была бы максимальной.</font></P>
<P> 
<TABLE BORDER CELLSPACING=1 CELLPADDING=7 WIDTH=250>
  <TR> 
    <TD WIDTH="59%" VALIGN="MIDDLE" BGCOLOR="#c0c0c0">  
      <P ALIGN="CENTER">Номер 
        товара, i</font></FONT></TD>
    <TD WIDTH="18%" VALIGN="MIDDLE" BGCOLOR="#c0c0c0">  
      <P ALIGN="CENTER">m<SUB>i</SUB></font></FONT></TD>
    <TD WIDTH="23%" VALIGN="MIDDLE" BGCOLOR="#c0c0c0">  
      <P ALIGN="CENTER">C<SUB>i</SUB></font></FONT></TD>
  </TR>
  <TR> 
    <TD WIDTH="59%" VALIGN="MIDDLE" BGCOLOR="#c0c0c0">  
      <P ALIGN="CENTER">1</font></FONT></TD>
    <TD WIDTH="18%" VALIGN="MIDDLE">  
      <P ALIGN="CENTER">5</font></FONT></TD>
    <TD WIDTH="23%" VALIGN="MIDDLE">  
      <P ALIGN="CENTER">9</font></FONT></TD>
  </TR>
  <TR> 
    <TD WIDTH="59%" VALIGN="MIDDLE" BGCOLOR="#c0c0c0">  
      <P ALIGN="CENTER">2</font></FONT></TD>
    <TD WIDTH="18%" VALIGN="MIDDLE">  
      <P ALIGN="CENTER">7</font></FONT></TD>
    <TD WIDTH="23%" VALIGN="MIDDLE">  
      <P ALIGN="CENTER">13</font></FONT></TD>
  </TR>
  <TR> 
    <TD WIDTH="59%" VALIGN="MIDDLE" BGCOLOR="#c0c0c0">  
      <P ALIGN="CENTER">3</font></FONT></TD>
    <TD WIDTH="18%" VALIGN="MIDDLE">  
      <P ALIGN="CENTER">11</font></FONT></TD>
    <TD WIDTH="23%" VALIGN="MIDDLE">  
      <P ALIGN="CENTER">21</font></FONT></TD>
  </TR>
</TABLE>
</P> 
<P>Максимальная грузоподъемность: М=23; 24.</font></P>
<P>Решение: </font></P>
<P>Вычислим <I>f(М) </I>– максимально возможную стоимость товаров 
  при грузоподъемности <I>М</I>:</font></P>
</font><I> 
<P>f(0)=0;</font></P>
<P>f(1)=0;</font></P>
<P>f(2)=0;</font></P>
<P>f(3)=0;</font></P>
<P>f(4)=0;</font></P>
<P>f(5)=max(f(5–5)+9, f(5–7)+13, 
  f(5–11)+21)= max(0+9)=9;</font></P>
<P>f(6)=max(f(6–5)+9, f(6–7)+13, 
  f(6–11)+21)= max(0+9)=9;</font></P>
<P>f(7)=max(f(7–5)+9, f(7–7)+13, 
  f(7–11)+21)= max(0+9, 0+13)=13;</font></P>
<P>f(8)=max(f(8–5)+9, f(8–7)+13, 
  f(8–11)+21)= max(0+9, 0+13)=13;</font></P>
<P>f(9)=max(f(9–5)+9, f(9–7)+13, 
  f(9–11)+21)= max(0+9, 0+13)=13;</font></P>
<P>f(10)=max(f(10–5)+9, f(10–7)+13, 
  f(10–11)+21)= max(9+9, 0+13)=18;</font></P>
<P>f(11)=max(f(11–5)+9, f(11–7)+13, 
  f(11–11)+21)= max(9+9, 0+13, 0+21)=21;</font></P>
<P>f(12)=max(f(12–5)+9, f(12–7)+13, 
  f(12–11)+21)= max(13+9, 9+13, 0+21)=22;</font></P>
<P>f(13)=max(f(13–5)+9, f(13–7)+13, 
  f(13–11)+21)= max(13+9, 9+13, 0+21)=22;</font></P>
<P>f(14)=ma(f(14–5)+9, f(14–7)+13, 
  f(14–11)+21)= max(13+9, 13+13, 0+21)=26;</font></P>
<P>f(15)=max(f(15–5)+9, f(15–7)+13, 
  f(15–11)+21)= max(18+9, 13+13, 0+21)=27;</font></P>
<P>f(16)=max(f(16–5)+9, f(16–7)+13, 
  f(16–11)+21)= max(21+9, 13+13, 9+21)=30;</font></P>
<P>f(17)=max(f(17–5)+9, f(17–7)+13, 
  f(17–11)+21)= max(22+9, 18+13, 9+21)=31;</font></P>
<P>f(18)=max(f(18–5)+9, f(18–7)+13, 
  f(18–11)+21)= max(22+9, 21+13, 13+21)=34;</font></P>
<P>f(19)=max(f(19–5)+9, f(19–7)+13, 
  f(19–11)+21)= max(26+9, 22+13, 13+21)=35;</font></P>
<P>f(20)=max(f(20–5)+9, f(20–7)+13, 
  f(20–11)+21)= max(27+9, 22+13, 13+21)=36;</font></P>
<P>f(21)=max(f(21–5)+9, f(21–7)+13, 
  f(21–11)+21)= max(30+9, 26+13, 18+21)=9;</font></P>
<P>f(22)=max(f(22)+9, f(22)+13, 
  f(22–11)+21)= max(31+9, 27+13, 21+21)=42;</font></P>
<P>f(23)=max(f(23–5)+9, f(23–7)+13, 
  f(23–11)+21)= max(34+9,30+13, 22+21)=43;</font></P>
<P>f(24)=max(f(24–5)+9, f(24–7)+13, 
  f(24–11)+21)= max(35+9, 31+15, 22+21)=44.</font></P>
</I> 
<P>Определим оптимальный набор 
  товаров при <I>М</I>=23:</font></P>
<I> 
<P>f(23)=43;</font></P>
</I> 
<p><I>f(23–5)+9=f(18)+9=34+9=43; 
  </I></font></p>
<IMG SRC="img/01.gif" > <IMG SRC="img/02.gif" > 
<IMG SRC="img/03.gif" > 
<p><IMG SRC="img/04.gif" ></p>

<br><br>
<!--конец-->
      
				

				</div>
			</div>
			
      </div>
    </div>
  </div>
	
	<!--Меню навигации по Темам -->	
	<div aria-label="..." class = "nav-menu">
	 <ul class="pager background-transition-slow">
		 <li title="Наверх" style = "margin-right:15px;	"><a class = "glyphicon glyphicon-menu-up page-scroll" href="#page-top"></a></li>
		 <li title="К предыдущей лекции"><a class = "glyphicon glyphicon-menu-left page-scroll" href="t3.htm"></a></li>
		 <li title="В содержание"><a class = "glyphicon glyphicon-list-alt" href="lec_index.htm"></a></li>
		 <!--li title="К следующей лекции"><a class = "glyphicon glyphicon-menu-right page-scroll" href="t2.htm"></a></li-->
	 </ul>
	</div>
	<!---->
	
	</div>
  <!-- jQuery -->
  <script src="../lib/js/jquery.js"></script>

  <!-- Bootstrap Core JavaScript -->
  <script src="../lib/js/bootstrap.min.js"></script>

  <!-- Scrolling Nav JavaScript -->
  <script src="../lib/js/jquery.easing.min.js"></script>
  <script src="../lib/js/scrolling-nav.js"></script>

</body>

</html>
